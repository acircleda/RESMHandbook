# Data Preparation and Cleaning in R

```{r package_setup, echo=FALSE, message=FALSE, warning=FALSE}
library(psych)
library(tidyverse)
library(skimr)
```

This chapter will introduce you to viewing your data, summarizing your data, and cleaning your data following recommendations from the [*Brief Introduction to the 12 Steps of Data Cleaning*](https://www.slideshare.net/jamorrow/brief-introduction-to-the-12-steps-of-evaluagio) (Morrow, 2013)

## Viewing Your Data

First, let's load some data. We will be working with [R Studio's "Learning R Survey"](https://github.com/rstudio/learning-r-survey).

We will load the data from the URL:

```{r}
raw_data <- read.csv("https://github.com/rstudio/learning-r-survey/blob/master/2019/data/2019%20English%20R%20Community%20Survey%20Responses%20.csv?raw=true")
```

### Using the RStudio Environment

There are several ways to view this data using the R Studio environment:

1. Type the name in the **console**.
  + This is not useful for a large data frame.
2. Double-click the data object in the **environment**.
  + This will open up the dataframe in the **source** pane, and you can easily browse the data.
  + You can do the same thing using the `view()` function, i.e. `view(raw_data)`.

### Using the str() function

You can use `str()` to view how your data is structured. That is, whether variables are numeric, characters, factors. If they are factors, you can also see what their levels are. I recommend using `str()` in the **console** not your script.

This is a very wide dataframe (52 variables/columns), so I will use the following code just to view the structure of the first 5 columns.

```{r}
str(raw_data[1:5])
```

Here is what we did:

* `str(raw_data)` tells R you want to look at the structure of the data object.
* `[1:5]` tells R you just want to look at columns 1 to 5

Here is what the output means:

1. "Timestamp" contains dates but is being read as a **factor**. Factors are like categories. Multiple data points can share a factor.
  + This can be converted into a date later using the `lubridate` package
2. "How.would.you.rate.your.level.of.experience.using.R." is also a factor. It has 5 levels or categories. "Beginner" is one level. The numbers after the list correspond to the levels of the factors. For example, "Beginner" might be 1 or 2 or 3. We will investigate this more later.
3. "Compared.with.other...." has the class **integer** (int). This is a number. The first 10 numbers are all NA (missing).

If you just want to examine a single variable, you can use the **`$`** operator:

```{r}
str(raw_data$In.what.country.do.you.currently.reside.)
```

If you just want to see the class of a variable, you can use the `class` function:

```{r}
class(raw_data$What.year.did.you.first.start.learning.R.)
```

### Using the names() function

The `names()` function is useful if you just want a list of the variable names.

```{r}
names(raw_data[1:5])
```

### Using the head() function

The `head()` function gives you a slightly more detailed look at your data. It will give you the column name and the first 10 data points (by default):

```{r}
head(raw_data[1:5])
```

You can also request more or less data points per column:

```{r}
head(raw_data[1:5], n = 3)
```

Or you can request data from a single variable:

```{r}
head(raw_data$How.likely.are.you.to.recommend.R.to.a.colleague..friend..or.family.member., n = 20)
```

`head()` looks at the head or top of the data. `tail()` looks at the bottom:

```{r}
tail(raw_data$How.likely.are.you.to.recommend.R.to.a.colleague..friend..or.family.member., n = 20)
```

### Using the describe() function

The `psych` package offers a very useful funcion called `describe()`. This function gives you summary statistics about your data. In particular, it will give you:

* item name 
* item number 
* number of valid cases
* mean
* standard deviation
* trimmed mean (with trim defaulting to .1) 
* median (standard or interpolated
* mad: median absolute deviation (from the median). 
* minimum
* maximum
* skew
* kurtosis
* standard error

Load the `psych` package at the top of your script using `library(psych)`. Then, you can execute this command.

The following command describes the third variable (according to our `str()` function, that variable is numeric):

```{r}
describe(raw_data[3])
```

See more options using `?describe` in the **console**.

### Using the summary() function

The `summary()` function will give similar statistics as `describe()`, though with less detail. For **factors**, it will produce a count per level (category). For **integers** it will produce min, max, quartiles, median, mean, and number of missing data.

The following `summary()` function calls columns 2 (a factor) and 3 (an integer)

```{r}
summary(raw_data[2:3])
```

### Using the skim() function

`skim` is another function that produces summary statistics. It will also produce a small histogram to show the distribution of your data (for numeric/integers).

First, install the `skimr` package in the **console** using:

```install.packages("skimr")```

Add ```library(skimr)``` to the top of your script after installation.

Then, we can use the `skim()` function like this:

```{r}
skim(raw_data[2:3])
```

## Introduction to the Tidyverse

The `Tidyverse` is a set of packages that make R easier to use. All the packages work together and share an underlying grammar and philosophy. That's right - philosophy. The `Tidyverse` operates on the assumption that data should be "tidy".

According to Hadley Wickham,Chief Scientist at RStudio and one of the creators of the `Tidyverse`: 

> Tidy data is a standard way of mapping the meaning of a dataset to its structure. A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types. In tidy data:
> 1. Each variable forms a column.
> 2. Each observation forms a row.
> 3. Each type of observational unit forms a table.

You can read more in [*Tidy Data* from the Journal of Statistic Software](https://www.jstatsoft.org/article/view/v059i10/v59i10.pdf).

The `Tidyverse` not only helps keep data "tidy," but makes programming easier compared to the base R syntax. Compare:

### Extracting a variable

**Tidyverse**
```
select(iris, Species, Petal.Width) # by name
select(iris, 5, 4)  # by column index
```
**Base R**
```
iris[, c("Species", "Petal.Width")] # by name
iris[, c(5, 4)]  # by column index
```
### Make new variables (columns)

**Tidyverse**
```
iris %>%
mutate(Petal.Ratio = Petal.Length/Petal.Width,
       Sepal.Ratio = Sepal.Length/Sepal.Width)
```

**Base R**
```
iris$Petal.Ratio <- iris$Petal.Length/iris$Petal.Width
iris$Sepal.Ratio <- iris$Sepal.Length/iris$Sepal.Width
```
(see more examples [here](https://tavareshugo.github.io/data_carpentry_extras/base-r_tidyverse_equivalents/base-r_tidyverse_equivalents.html))

Most of this handbook will use `Tidyverse` functions, as they are clearly easier to work with.

## Renaming Variables

If you have noticed, the variable names for the R survey are very long. This is not convenient to work with.

R Studio provides us with a useful [code book](https://github.com/rstudio/learning-r-survey/blob/master/2019/Learning%20R%20Internet%20Survey%20-%20Question%20Names.tsv) to help us fix this problem.

A common way of renaming columns is to use the `rename()` function. This function is part of one of the most useful packages you will download and install: `tidyverse`.

To begin, install tidyverse through the **console**: `install.packages("tidyverse")`. Then load it at the top of your script:
`library(tidyverse)`. Don't forget to run this line of code!

The first column's name is already simple: *Timestamp*. So, let's rename the second column.

First, let's get the column name (run this in the **console**:

```{r}
names(raw_data[2])
```

Now, we can use the `rename()` function to change this to "Qr_experience", as listed in the codebook. We will assign this to a new data object for comparison purposes. Put this in your script.

```{r}
renamed <- raw_data %>%
  rename("Qr_experience" = "How.would.you.rate.your.level.of.experience.using.R.")

```

Let's see the new name:

```{r}
# new name
names(renamed[1:2])
```

So, what did we do?

* `renamed <-` creates a new data object
* `raw_data` says which data object we are working with
* `%>%` is the pipe operator. This means something like "and"
* `rename("new_name" = "old name")` sets the name name and the old name. Note the quotation marks

We can read this line as a sentence: Create a data object, "renamed". Use the "raw_data" object and rename "new_name" from "old_name".


## Renaming Multiple Variables

We can also rename multiple columns the same way:

```{r}
renamed <- raw_data %>%
  rename("Qr_experience" = "How.would.you.rate.your.level.of.experience.using.R.",
         "Qr_difficulty_experienced" = "Compared.with.other.technical.topics.you.ve.learned.in.school.and.on.the.job..on.a.scale.of.1.to.5..how.difficult.do.you.expect.learning.R.to.be.")

```

Let's check:

```{r}
# new name
names(renamed[2:3])
```

However, raw_data has 52 variables! This would take a *long* time to do.
Instead of writing 52+ lines of code, we can use the `setnames()` function from the `data.table` package.

Install `data.table`:

**Console**: `install.packages("data.table")`.

The R Studio survey provides us with a .tsv file of proper variable names for the columns. Let's load that first:

```{r message=FALSE}
qnames <- read_tsv("https://raw.githubusercontent.com/rstudio/learning-r-survey/master/2019/data/2019-english-question-names-only.tsv")
```

Now, we can use `setnames`:

```{r}
renamed <- raw_data %>%
  data.table::setnames(
    old = names(raw_data),
    new = names(qnames)
  )
```

>Recall that `::` means we are using a package's function without loading the package.

Let's check:

```{r}
names(renamed[1:10])
```

## Cleaning Names with janitor

Let's make sure all the names are lowercase. This will make typing them in later analyses easier, as you don't ever need to remember what is capital and what is not. Install the `janitor` package:

**Console**: `install.packages("janitor")`.

Run the following code:

```{r}
renamed <- renamed %>% 
  janitor::clean_names()
```

Let's check:

```{r}
names(renamed[1:10])
```

The `clean_names()` function will do a number of things:

* convert to lower case
* change spaces into underscores
* change % signs to "percentage"

There are many cool options, so please check `?janitor::clean_names`.

## Keeping and Dropping Variables

We can use `select()` to keep specific variables or drop other variables.

**Keeping** variables:

```{r}
keep <- renamed %>% select(qr_experience, qr_year)
```

To **drop** variables, use the *minus* sign.

```{r}
dropped <- renamed %>% select(-qr_experience, -qr_year)
```

## More Frequencies and Descriptives

You can use any of the following functions to get frequencies of your data:

* `summary()`
* `describe()` from the `psych` package
* `skim()` from the `skimr` package

Let's use the `jmv` package the get some frequencies:

**Console**: `install.packages("jmv")`

We will use the `descriptives()` function. This will provide nice output. We will use the parameter `freq=TRUE` to get frequencies for factors.

```{r message=TRUE, warning=FALSE}
library("jmv")

renamed %>%
  select(qr_experience, qr_year) %>%
  descriptives(freq = TRUE)
```

## Spotting Coding Mistakes

You may have noticed that the descriptives for "qr_year" had a minimum of 2. The question reads "What year did you first start learning R?". This should only contain year data. By running frequencies, you can spot such errors. Let's take a closer look.

Let's start by viewing all the data in this question. Since it is year data, let's arrange it from smallest to greatest and look at the first 10 observations.

```{r}
renamed %>%
  select(qr_year) %>%
  arrange(qr_year) %>%
  head(n = 10)
```

Let's review what we did in the code:

* `renamed %>%` tells R to use "renamed" and...
* `select(qr_year) %>%` select the "qr_year" variable and...
* `arrange(qr_year) %>%` arrange the data based on the "qr_year" variable and...
* `head(n = 10)` get the first 10 responses.

From the results, we saw that the first 5 responses are invalid years.

## Modifying Data - mutate()

We have a variable, "qr_year" with five invalid cases. They should be years, but are some other numbers. Let's change those to mising observations using `mutate()`. `mutate()` allows us to change and create variables (literally mutate the data).

```{r}
#run this to change the variable
renamed <- renamed %>%
  mutate(qr_year2 = ifelse(qr_year < 1977, NA, qr_year))

#run this to check
renamed %>%
  select(qr_year, qr_year2) %>%
  arrange(qr_year) %>%
  head(n=10)
```

What we did:

* `renamed <-` means we will save our fixed data to the renamed data object. Essentially, we are overwriting the data object that already exists.
* `renamed %>%` tells R to use "renamed" and...
* `mutate(qr_year2` create a new variable, "qr_year2"
* `=` which is equal to the following command
* `ifelse(qr_year < 1977, NA, qr_year))` if qr_year is less than 1977, write NA, otherwise (`else`), write the year from qr_year

`ifelse` is a conditional statement that says: `ifelse(if this condition is true, then do this, otherwise do this)`.

## Reordering Categories - factor()

Recode allows you to take a numeric value in a dataset and assign it a label, for example make 1 = "apple", or the opposite, for example, make "apple" = 1.

Many of the factors (categories) in our R survey dataset have already been coded to a numeric value, automatically. However, this does not mean the mapping of the number to the factor is correct.

Let's run this code in the **console** to check. Since we are just checking, we don't really want to include this in our script, so we can do basic exploration in the console.


```{r}
renamed %>% count(qr_experience)
```

You will see that 1 = "", which is missing data, 2 = "Beginner", 3 = "Expert", 4 = "Intermediate" and 5 = "None". If we were doing a statistical analysis without modifying our data, our results would be severely inaccurate.

Let's recode this data. We will just do one variable as an example.

```{r}
recoded <- renamed %>% 
  select(qr_experience) %>%
  mutate(qr_experience2 = factor(qr_experience,
        levels=c("None","Beginner", "Intermediate", "Expert", NA ))
  )
```

Let's check if we are correct. You can run this in the **console**:
```{r}
recoded %>% count(qr_experience2)
```

Now our factors are in the correct order and if we wanted to do some statistical test, it would be much more accurate.

What did we do?

* `recoded <-` creates a new data object. We could have overwritten our previous object, but this is to show you the result of recoding.
* `renamed %>%` tells R to use the "renamed" data object and...
* `select(qr_experience) %>%` means we are only going to keep this variable in our data (to make demonstration easier), and 
* `mutate(` means we are going to make a change
* `qr_experience2 =` we will create a new variable "qr_experience2" equal to the next command
  + Note: we could have done `mutate(qr_experience)` and overwritten our column, but if we create a new variable, we can compare them side by side (for demonstration purposes)
* `factor(qr_experience,` make a factor from "qr_experience"
* `levels=c("None","Beginner", "Intermediate", "Expert", NA ))` set the level names and orders to these.
  + Note that `NA` refers to missing data and is **not** in quotes
* `)` this final parentheses closes the `mutate` function. If you place your cursor after it, the corresponding opening parentheses will be highlighted. This is an easy way to check that you have closed all functions, useful for debugging problems.
  )
  
## Recoding Factors

## Reverse coding

## Creating new variables with mutate()

## Combining variables

### Numeric variables with mutate()

### String variables with paste0()

### Splitting variables with split()

## Descirptives

### Mean

### Median

### Using the summarize() function

## Wide and Long Data

### Long Data

### Wide Data